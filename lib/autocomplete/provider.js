// Generated by CoffeeScript 1.12.0
(function() {
  var FileUtils, chokidar, esprima, fs, path;

  fs = require('fs');

  path = require('path');

  esprima = require('esprima');

  chokidar = require('chokidar');

  FileUtils = require('../file/file-utils');

  path = require('path');

  module.exports = {
    selector: '.source.js, .source.coffee',
    disableForSelector: '.source.js .comment',
    filterSuggestions: true,
    suggestionPriority: 1,
    getSuggestions: function(arg1) {
      var bufferPosition, editor, func, funcSuggestion, i, j, k, key, l, len, len1, len2, len3, len4, len5, len6, len7, len8, m, n, o, p, prefix, prop, q, ref, ref1, ref10, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, strArray, suggestion, suggestionSet, suggestions, value;
      editor = arg1.editor, bufferPosition = arg1.bufferPosition;
      prefix = this.getPrefix(editor, bufferPosition).trim();
      suggestions = [];
      if (prefix.toLowerCase().includes('yyapi')) {
        ref = this.getYYApiPackage().concat(this.getApiEnt()).concat(this.getApiRes()).concat(this.getApiUtils());
        for (i = 0, len = ref.length; i < len; i++) {
          suggestion = ref[i];
          suggestion.replacementPrefix = prefix;
          suggestion.descriptionMoreURL = 'http://dev.yypm.com/yylive/? post=posts/yyscriptpluginsdk/api.md';
          suggestions.push(suggestion);
        }
      } else if (prefix.toLowerCase().includes('self.ysp')) {
        ref1 = this.getYSPNotify();
        for (j = 0, len1 = ref1.length; j < len1; j++) {
          suggestion = ref1[j];
          suggestion.replacementPrefix = prefix;
          suggestion.descriptionMoreURL = 'http://dev.yypm.com/yylive/? post=posts/yyscriptpluginsdk/api.md';
          suggestions.push(suggestion);
        }
      } else if (prefix.toLowerCase().includes('disp')) {
        ref2 = this.getOcDispatch();
        for (k = 0, len2 = ref2.length; k < len2; k++) {
          suggestion = ref2[k];
          suggestion.replacementPrefix = prefix;
          suggestions.push(suggestion);
        }
      } else if (prefix.toLowerCase().includes('self.')) {
        ref3 = this.getYSPApi();
        for (l = 0, len3 = ref3.length; l < len3; l++) {
          suggestion = ref3[l];
          suggestion.replacementPrefix = prefix;
          suggestions.push(suggestion);
        }
      } else if (prefix.toLowerCase().includes('block')) {
        ref4 = this.getBlock();
        for (m = 0, len4 = ref4.length; m < len4; m++) {
          suggestion = ref4[m];
          suggestion.replacementPrefix = prefix;
          suggestions.push(suggestion);
        }
      }
      if (prefix.toLowerCase().includes('.')) {
        ref5 = this.all_completions;
        for (n = 0, len5 = ref5.length; n < len5; n++) {
          suggestion = ref5[n];
          strArray = prefix.split('.');
          suggestion.replacementPrefix = strArray[strArray.length - 1];
          suggestions.push(suggestion);
        }
      }
      this.classes.forEach(function(name) {
        suggestion = {};
        suggestion.text = name;
        suggestion.leftLabel = "YYMobile";
        suggestion.type = 'class';
        strArray = prefix.split(' ');
        suggestion.replacementPrefix = strArray[strArray.length - 1];
        return suggestions.push(suggestion);
      });
      ref6 = this.LocalYYClassCompletes;
      for (key in ref6) {
        value = ref6[key];
        suggestion = {};
        suggestion.text = value.className;
        suggestion.leftLabel = "YYClass";
        suggestion.type = 'class';
        strArray = prefix.split(' ');
        suggestion.replacementPrefix = strArray[strArray.length - 1];
        suggestions.push(suggestion);
        if (prefix.toLowerCase().includes('.')) {
          ref7 = value.functions;
          for (o = 0, len6 = ref7.length; o < len6; o++) {
            func = ref7[o];
            funcSuggestion = {};
            funcSuggestion.text = func.methodName + '(' + func.params + ')';
            funcSuggestion.leftLabel = value.className;
            funcSuggestion.type = 'method';
            strArray = prefix.split('.');
            funcSuggestion.replacementPrefix = strArray[strArray.length - 1];
            suggestions.push(funcSuggestion);
          }
          ref8 = value.propertys;
          for (p = 0, len7 = ref8.length; p < len7; p++) {
            prop = ref8[p];
            suggestion = {};
            suggestion.text = prop + '()';
            suggestion.leftLabel = value.className;
            suggestion.type = 'method';
            suggestions.push(suggestion);
            suggestionSet = {};
            suggestionSet.text = 'set' + prop.charAt(0).toUpperCase() + prop.slice(1) + "(" + prop + ")";
            suggestionSet.leftLabel = value.className;
            suggestionSet.type = 'method';
            suggestions.push(suggestionSet);
          }
        }
      }
      ref9 = this.LocalProtocolCompletes;
      for (key in ref9) {
        value = ref9[key];
        suggestion = {};
        suggestion.text = value.protocolName;
        suggestion.leftLabel = "YYProtocol";
        suggestion.type = 'class';
        strArray = prefix.split(' ');
        suggestion.replacementPrefix = strArray[strArray.length - 1];
        suggestions.push(suggestion);
        if (prefix.toLowerCase().includes('.')) {
          ref10 = value.functions;
          for (q = 0, len8 = ref10.length; q < len8; q++) {
            func = ref10[q];
            funcSuggestion = {};
            funcSuggestion.text = func.methodName + '(' + func.params + ')';
            funcSuggestion.leftLabel = value.protocolName;
            funcSuggestion.type = 'method';
            strArray = prefix.split('.');
            funcSuggestion.replacementPrefix = strArray[strArray.length - 1];
            suggestions.push(funcSuggestion);
          }
        }
      }
      return suggestions;
    },
    getBlock: function() {
      var suggestions;
      suggestions = [
        {
          text: 'BlockD( function(data) {\n # body...\n})',
          type: 'function',
          description: '只有一个NSDictionary参数的Block'
        }, {
          text: 'block(function() {\n # body...\n})',
          snippet: 'block(function(${1:args}) {\n # body...\n})',
          type: 'function',
          description: 'JS中传递Block作为参数的形式'
        }, {
          text: 'blockNotify( function(object,userinfo) {\n # body...\n})',
          type: 'function',
          description: '用于yspNotify的Block定义'
        }
      ];
      return suggestions;
    },
    getYSPApi: function() {
      var suggestions;
      suggestions = [
        {
          text: 'self.observeModuleWithIdentifier()',
          type: 'function',
          description: '监听对应的VC'
        }, {
          text: 'self.removeObserverWithIdentifier()',
          type: 'function',
          description: '移除对应的VC监听'
        }
      ];
      return suggestions;
    },
    getYYApiPackage: function() {
      var suggestions;
      suggestions = [
        {
          text: 'YYAPI.ent',
          snippet: 'YYAPI.ent',
          type: 'class',
          description: 'Ent 相关接口'
        }, {
          text: 'YYAPI.res',
          snippet: 'YYAPI.res',
          displayText: 'YYAPI.res',
          type: 'class',
          description: 'Res 相关接口'
        }, {
          text: 'YYAPI.log()',
          type: 'function',
          description: '普通日志接口'
        }, {
          text: 'YYAPI.error()',
          type: 'function',
          description: '错误日志接口'
        }, {
          text: 'YYAPI.warning()',
          type: 'function',
          description: '警告日志接口'
        }, {
          text: 'YYAPI.info()',
          type: 'function',
          description: 'info日志接口'
        }, {
          text: 'YYAPI.debug()',
          type: 'function',
          description: '调试日志接口'
        }, {
          text: 'YYAPI.utils',
          snippet: 'YYAPI.utils',
          type: 'class',
          description: 'Utils 相关接口'
        }
      ];
      return suggestions;
    },
    getApiEnt: function() {
      var addCoreClient, notifyCoreClient, registerEntProtocol, registerEntStruct, removeAllCoreClient, removeCoreClient, sendEntProtocol;
      sendEntProtocol = {
        text: 'YYAPI.ent.sendEntProtocolByMaxType_minType_info();',
        type: 'function',
        description: '通过大小端号发送协议'
      };
      registerEntProtocol = {
        text: 'YYAPI.ent.registerEntProtocolByMaxType_minType_block();',
        type: 'function',
        description: '通过大小端号注册协议回调'
      };
      registerEntStruct = {
        text: 'YYAPI.ent.registerEntStructByMaxType_minType_info();',
        type: 'function',
        description: '通过大小端号注册协议结构'
      };
      addCoreClient = {
        text: 'YYAPI.ent.addCoreClient_protocl();',
        type: 'function',
        description: '监听Protocol'
      };
      removeCoreClient = {
        text: 'YYAPI.ent.removeCoreClient_protocl();',
        type: 'function',
        description: '移除监听'
      };
      removeAllCoreClient = {
        text: 'YYAPI.ent.removeAllCoreClient();',
        type: 'function',
        description: '移除所有的监听'
      };
      notifyCoreClient = {
        text: 'YYApi.ent.notifyCoreClientWithProtocl_selector_argsType_args();',
        type: 'function',
        description: '协议通知'
      };
      return [sendEntProtocol, registerEntProtocol, registerEntStruct, addCoreClient, removeCoreClient, removeAllCoreClient, notifyCoreClient];
    },
    getApiRes: function() {
      var suggestions;
      suggestions = [
        {
          text: 'YYAPI.res.image();',
          type: 'function',
          description: '获取组件下图片资源'
        }, {
          text: 'YYAPI.res.path();',
          type: 'function',
          description: '获取组件下图片资源地址'
        }, {
          text: 'YYAPI.res.createView();',
          type: 'function',
          description: '根据xib资源id生成View'
        }
      ];
      return suggestions;
    },
    getYSPNotify: function() {
      var yspAddNotify, yspPostNotify, yspRemoveAllNotify, yspRemoveNotify;
      yspAddNotify = {
        text: 'self.yspAddNotify_block("name",blockNotify(function(object,userinfo){ });',
        type: 'function',
        description: '添加notify监听'
      };
      yspPostNotify = {
        text: 'self.yspPostNotify_object_userinfo("name",null,null);',
        type: 'function',
        description: '发送notify'
      };
      yspRemoveNotify = {
        text: 'self.yspRemoveNotify("name");',
        type: 'function',
        description: '移除指定notifyname'
      };
      yspRemoveAllNotify = {
        text: 'self.yspRemoveAllNotify();',
        type: 'function',
        description: '移除所有notify'
      };
      return [yspAddNotify, yspPostNotify, yspRemoveNotify, yspRemoveAllNotify];
    },
    getApiUtils: function() {
      var i, len, suggestion, suggestions;
      suggestions = [
        {
          text: 'YYAPI.utils.deleteFileWithFullPath();',
          description: '删除文件'
        }, {
          text: 'YYAPI.utils.isFileExists();',
          description: '判断文件是否存在'
        }, {
          text: 'YYAPI.utils.createDirForPath();',
          description: '创建文件夹'
        }, {
          text: 'YYAPI.utils.readFile();',
          description: '读文件'
        }, {
          text: 'YYAPI.utils.getAppSource();',
          description: '获取appSource'
        }, {
          text: 'YYAPI.utils.getappVersion();',
          description: '获取appVersion'
        }, {
          text: 'YYAPI.utils.isFromAppStore();',
          description: '获取是否是App Store渠道'
        }, {
          text: 'YYAPI.utils.modelName();',
          description: '获取modelName'
        }, {
          text: 'YYAPI.utils.systemVersion();',
          description: '获取systemVersion'
        }, {
          text: 'YYAPI.utils.identifierForVendor();',
          description: '获取当前设备的 IDFV，IDFV 在某些情况下会变，不建议将其作为设备标识'
        }, {
          text: 'YYAPI.utils.deviceID();',
          description: '获取deviceID'
        }, {
          text: 'YYAPI.utils.networkStatus();',
          description: '获取网络状态'
        }, {
          text: 'YYAPI.utils.reachableStatus();',
          description: '获取网络状态，精确到2，3，4G'
        }, {
          text: 'YYAPI.utils.ipAddress();',
          description: '获取ipAddress'
        }, {
          text: 'YYAPI.utils.ipAddress(true);',
          description: '获取ipAddress 优先取IPv4的地址'
        }, {
          text: 'YYAPI.utils.macAddresss();',
          description: '获取macAddresss'
        }, {
          text: 'YYAPI.utils.idfa();',
          description: '获取idfa'
        }, {
          text: 'YYAPI.utils.carrier();',
          description: '获取运营商'
        }, {
          text: 'YYAPI.utils.carrierIdentifier();',
          description: '获取运营商类型'
        }, {
          text: 'YYAPI.utils.carrierName();',
          description: '获取运营商名称'
        }
      ];
      for (i = 0, len = suggestions.length; i < len; i++) {
        suggestion = suggestions[i];
        suggestion.type = 'function';
      }
      return suggestions;
    },
    getOcDispatch: function() {
      var i, len, suggestion, suggestions;
      suggestions = [
        {
          text: 'dispatch_after(second,function() {\n // do something\n })',
          snippet: 'dispatch_after(${1:#second},function() {\n // do something\n })',
          description: 'GCD 支持'
        }, {
          text: 'dispatch_async_main(function() {\n // do something\n })',
          description: 'GCD 支持'
        }, {
          text: 'dispatch_sync_main(function() {\n // do something\n })',
          description: 'GCD 支持'
        }, {
          text: 'dispatch_async_global_queue(function() {\n  // do something\n})',
          description: 'GCD 支持'
        }
      ];
      for (i = 0, len = suggestions.length; i < len; i++) {
        suggestion = suggestions[i];
        suggestion.type = 'function';
      }
      return suggestions;
    },
    init: function() {
      this.all_completions = [];
      return this.classes = new Set();
    },
    loadAppCompletions: function() {
      return fs.readFile(path.resolve(__dirname, '.', 'AutoComplete.json'), (function(_this) {
        return function(error, content) {
          var completions, i, len, method, object, params, results, suggestion;
          if (error == null) {
            completions = JSON.parse(content);
          }
          results = [];
          for (i = 0, len = completions.length; i < len; i++) {
            object = completions[i];
            suggestion = {};
            method = object.method.replace(/\:$/, "");
            method = method.replace(/\:/g, "_");
            method = method.concat("(");
            params = object.paramsDesc.split(",");
            params.forEach(function(item, index, array) {
              method = method.concat("${", index, ":", params[index], "}");
              if (index < params.length - 1) {
                return method = method.concat(",");
              }
            });
            method = method.concat(")");
            suggestion.snippet = method;
            suggestion.leftLabel = object.returnType;
            suggestion.type = 'method';
            suggestion.description = object.paramsDesc;
            _this.all_completions.push(suggestion);
            results.push(_this.classes.add(object["class"]));
          }
          return results;
        };
      })(this));
    },
    loadLocalComplete: function() {
      var projectPath, self, watcher;
      self = this;
      projectPath = FileUtils.iosProjectPath();
      if (FileUtils.isPathValid(projectPath)) {
        projectPath = path.join(projectPath, 'script');
        projectPath = projectPath.concat("/**/*.js");
      } else {
        return;
      }
      watcher = chokidar.watch(projectPath, {
        ignored: /(^|[\/\\])\../,
        persistent: true
      });
      this.LocalYYClassCompletes = {};
      this.LocalProtocolCompletes = {};
      return watcher.on('add', function(path) {
        return self.parseSyntax(path);
      }).on('change', function(path) {
        return self.parseSyntax(path);
      });
    },
    parseSyntax: function(filepath) {
      var i, len, ref, results, statement, text, token;
      text = fs.readFileSync(filepath, 'utf-8');
      token = esprima.parse(text);
      ref = token.body;
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        statement = ref[i];
        if (statement.type === "ExpressionStatement") {
          if (statement.expression.type === "CallExpression") {
            if (statement.expression.callee.name === "YYClass" || statement.expression.callee.name === "defineClass") {
              this.parseYYClass(statement.expression);
            }
            if (statement.expression.callee.name === "defineProtocol" || statement.expression.callee.name === "YYProtocol") {
              results.push(this.parseProtocol(statement.expression));
            } else {
              results.push(void 0);
            }
          } else {
            results.push(void 0);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    },
    parseProtocol: function(expression) {
      var arg, func, functions, i, j, k, len, len1, len2, param, params, prop, protocolName, ref, ref1, ref2, strArray;
      protocolName = '';
      functions = [];
      ref = expression["arguments"];
      for (i = 0, len = ref.length; i < len; i++) {
        arg = ref[i];
        if (arg.type === "Literal") {
          if (arg.value.includes(":")) {
            strArray = arg.value.split(':');
            protocolName = strArray[0];
          } else {
            protocolName = arg.value;
          }
        }
        if (arg.type === "ObjectExpression") {
          ref1 = arg.properties;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            prop = ref1[j];
            if (prop.value.type === "FunctionExpression") {
              func = {};
              params = [];
              func.methodName = prop.key.name;
              ref2 = prop.value.params;
              for (k = 0, len2 = ref2.length; k < len2; k++) {
                param = ref2[k];
                params.push(param.name);
              }
              func.params = params;
              functions.push(func);
            }
          }
        }
      }
      return this.LocalProtocolCompletes[protocolName] = {
        "protocolName": protocolName,
        "functions": functions
      };
    },
    parseYYClass: function(expression) {
      var arg, className, func, functions, i, j, k, l, len, len1, len2, len3, param, params, prop, propertys, ref, ref1, ref2, ref3, strArray;
      className = '';
      propertys = [];
      functions = [];
      ref = expression["arguments"];
      for (i = 0, len = ref.length; i < len; i++) {
        arg = ref[i];
        if (arg.type === "Literal") {
          if (arg.value.includes(":")) {
            strArray = arg.value.split(':');
            className = strArray[0];
          } else {
            className = arg.value;
          }
        }
        if (arg.type === "ArrayExpression") {
          ref1 = arg.elements;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            prop = ref1[j];
            propertys.push(prop.value);
          }
        }
        if (arg.type === "ObjectExpression") {
          ref2 = arg.properties;
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            prop = ref2[k];
            if (prop.value.type === "FunctionExpression") {
              func = {};
              params = [];
              func.methodName = prop.key.name;
              ref3 = prop.value.params;
              for (l = 0, len3 = ref3.length; l < len3; l++) {
                param = ref3[l];
                params.push(param.name);
              }
              func.params = params;
              functions.push(func);
            }
          }
        }
      }
      return this.LocalYYClassCompletes[className] = {
        "className": className,
        "propertys": propertys,
        "functions": functions
      };
    },
    getPrefix: function(editor, bufferPosition) {
      var line, regex;
      regex = /\ \S*$/g;
      line = editor.getTextInRange([[bufferPosition.row, 0], bufferPosition]);
      if (line.includes(' ')) {
        line = line.match(regex)[0];
      }
      return line;
    },
    onDidInsertSuggestion: function(arg1) {
      var editor, suggestion;
      editor = arg1.editor, suggestion = arg1.suggestion;
      if (suggestion.type === 'attribute') {
        return setTimeout(this.triggerAutocomplete.bind(this, editor), 1);
      }
    },
    triggerAutocomplete: function(editor) {
      return atom.commands.dispatch(atom.views.getView(editor), 'autocomplete-plus:activate', {
        activatedManually: false
      });
    }
  };

}).call(this);
